package main

import (
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"

	"github.com/BurntSushi/toml"
)

var (
	input  = flag.String("input", "", "Input file pattern (e.g., locale.*.toml)")
	typ    = flag.String("type", "LocaleFile", "Type name for the enum")
	output = flag.String("output", "locale_enum.go", "Output file name")
)

const enumTemplate = `// Code generated by gen_string_enum.go. DO NOT EDIT.

package {{.Package}}

import "fmt"

// {{.TypeName}} represents a localization message key as a string enum.
type {{.TypeName}} string

// Define all valid {{.TypeName}} values.
const (
{{- range .Values}}
	{{$.TypeName}}{{.ConstName}} {{$.TypeName}} = "{{.Value}}"
{{- end}}
)

// All{{.TypeName}}s makes it easy to list all values (great for tests, validation, etc.)
var All{{.TypeName}}s = []{{.TypeName}}{
{{- range .Values}}
	{{$.TypeName}}{{.ConstName}},
{{- end}}
}

// String satisfies fmt.Stringer (useful for logging, debugging)
func (l {{.TypeName}}) String() string {
	return string(l)
}

// Parse{{.TypeName}} parses a string into a {{.TypeName}} with validation
func Parse{{.TypeName}}(s string) ({{.TypeName}}, error) {
	for _, l := range All{{.TypeName}}s {
		if l.String() == s {
			return l, nil
		}
	}
	return "", fmt.Errorf("invalid {{.TypeName}} value: %q", s)
}
`

type enumData struct {
	Package  string
	TypeName string
	Values   []enumValue
}

type enumValue struct {
	ConstName string
	Value     string
}

func main() {
	flag.Parse()

	if *input == "" {
		fmt.Fprintf(os.Stderr, "Error: -input flag is required\n")
		os.Exit(1)
	}

	// Get the directory where the generator is running
	cwd, err := os.Getwd()
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error getting current directory: %v\n", err)
		os.Exit(1)
	}

	// Get package name from directory
	pkgName := filepath.Base(cwd)

	// Find matching files
	matches, err := filepath.Glob(*input)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error matching pattern: %v\n", err)
		os.Exit(1)
	}

	if len(matches) == 0 {
		fmt.Fprintf(os.Stderr, "No files matched pattern: %s\n", *input)
		os.Exit(1)
	}

	// Extract all unique message keys from all locale files
	keySet := make(map[string]bool)
	for _, match := range matches {
		keys, err := extractKeysFromTOML(match)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error reading %s: %v\n", match, err)
			os.Exit(1)
		}
		for _, key := range keys {
			keySet[key] = true
		}
	}

	// Convert to sorted slice
	var keys []string
	for key := range keySet {
		keys = append(keys, key)
	}
	sort.Strings(keys)

	// Build enum values
	var values []enumValue
	for _, key := range keys {
		constName := toConstantName(key)
		values = append(values, enumValue{
			ConstName: constName,
			Value:     key,
		})
	}

	// Generate output
	data := enumData{
		Package:  pkgName,
		TypeName: *typ,
		Values:   values,
	}

	tmpl, err := template.New("enum").Parse(enumTemplate)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error parsing template: %v\n", err)
		os.Exit(1)
	}

	outFile, err := os.Create(*output)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error creating output file: %v\n", err)
		os.Exit(1)
	}
	defer outFile.Close()

	if err := tmpl.Execute(outFile, data); err != nil {
		fmt.Fprintf(os.Stderr, "Error executing template: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Generated %s with %d message keys\n", *output, len(values))
}

// extractKeysFromTOML reads a TOML file and extracts all top-level keys
func extractKeysFromTOML(filename string) ([]string, error) {
	var data map[string]interface{}

	_, err := toml.DecodeFile(filename, &data)
	if err != nil {
		return nil, err
	}

	keys := make([]string, 0, len(data))
	for key := range data {
		keys = append(keys, key)
	}

	return keys, nil
}

// toConstantName converts a string to a Go constant name
// e.g., "Back" -> "Back", "continue_button" -> "ContinueButton"
func toConstantName(s string) string {
	// If already PascalCase, return as-is
	if isValidGoIdentifier(s) && s[0] >= 'A' && s[0] <= 'Z' {
		return s
	}

	// Handle snake_case, kebab-case, etc.
	parts := strings.FieldsFunc(s, func(r rune) bool {
		return r == '_' || r == '-' || r == ' '
	})

	var result strings.Builder
	for _, part := range parts {
		if part != "" {
			result.WriteString(strings.ToUpper(part[:1]))
			if len(part) > 1 {
				result.WriteString(part[1:])
			}
		}
	}

	name := result.String()
	if name == "" {
		return s
	}
	return name
}

// isValidGoIdentifier checks if a string is a valid Go identifier
func isValidGoIdentifier(s string) bool {
	if s == "" {
		return false
	}
	for i, r := range s {
		if i == 0 {
			if !((r >= 'a' && r <= 'z') || (r >= 'A' && r <= 'Z') || r == '_') {
				return false
			}
		} else {
			if !((r >= 'a' && r <= 'z') || (r >= 'A' && r <= 'Z') || (r >= '0' && r <= '9') || r == '_') {
				return false
			}
		}
	}
	return true
}
